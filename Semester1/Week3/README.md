## Работа с контейнерами C++

### Последовательные контейнеры

Для работы с последовательностями элементов наилучший выбор - `std::vector`, если вам
известен размер на этапе компиляции, то используйте - `std::array`.

Базовые методы для работы с `std::vector`:

* `push_back` - добавить элемент в конец контейнера, сложность - `amortized constant`
* `size` - получить размер, сложность - `O(1)`.
* `pop_back` - удалить последний элемент, ВАЖНО: можно словить UB, если вектор пустой,
 сложность - `O(1)`.
* `empty` - проверить пустой вектор или нет, сложность - `O(1)`.
* `operator[]` - получить элемент по индексу, ВАЖНО: можно словить UB, если передать
  несуществующий индекс, сложность - `O(1)`.
* `at` - получить элемент по индексу, отличается от `operator[]` тем, что проверяет что
  переданный индекс валидный, в случае отсутствия искомого элемента кинет исключение
  `std::out_of_range`. Не советую использовать, медленнее чем базовый `operator[]`,
  лучше проверить размер один раз через `size` или `empty`.
* `clear` - очистить вектор, ВАЖНО: зануляет `size`, но не `capacity`, т.е выделенная
  память под вектор не очищается, сложность - `O(N)`.
* `shrink_to_fit` - уменьшить `capacity` до текущего `size`, сложность - `O(N)`.
* `back` - получить последний элемент вектора, ВАЖНО: можно словить UB, если вектор
  пустой, сложность - `O(1)`.
* `front` - получить первый элемент вектора, ВАЖНО: можно словить UB, если вектор
  пустой, сложность - `O(1)`.

### Ассоциативные контейнеры

Для работы со парами `уникальный ключ - значение` наилучший выбор - `std::unorderd_map`,
для работы с множествами `уникальных ключей` наилучший выбор - `std::unordered_set`, эти
два контейнера еще классно работают в связке `std::unordered_map<key, std::unordered_set<>>>`.

Базовые методы для работы с `std::unordered_map`:

* `insert` - добавить элемент в контейнер. если ключ уже существует, значение будет обновлено.
  сложность: амортизированная `O(1)`, ВАЖНО: может произойти перезапись существующего значения.
* `size` - получить количество элементов в контейнере, сложность: `O(1)`.
* `erase` - удалить элемент по ключу, если ключ не существует, ничего не произойдет, сложность: `O(1)` в среднем случае.
* `empty` - проверить, пуст ли контейнер, сложность: `O(1)`.
* `operator[]` - получить значение по ключу, если ключ не существует, будет создан новый элемент с значением по умолчанию,
  сложность: `O(1)` в среднем случае, ВАЖНО: если ключ не существовал ранее (создается новый элемент).
* `at` - получить значение по ключу, в отличие от `operator[]`, если ключ не найден, будет выброшено исключение std::out_of_range.
  сложность: `O(1)` в среднем случае, ВАЖНО: выкинет исключение, если ключ не существует.
* `clear` - очистить контейнер, удаляя все элементы, сложность: `O(N)`.
* `find` - найти элемент по ключу и вернуть итератор на него или end(), если элемент не найден,
  сложность: `O(1)` в среднем случае, ВАЖНО: Возвращает итератор на end()`, если элемент не найден, что требует проверки перед разыменованием.
* `count` - получить количество элементов с заданным ключом (может быть 0 или 1 для unordered_map),
  сложность: `O(1)` в среднем случае.
* `bucket_count` - получить количество "ведер" (buckets), используемых контейнером,
  сложность: `O(1)`.
* `load_factor` - получить коэффициент загрузки контейнера (количество элементов на ведро).
  сложность: `O(1)`.
