# Move semantic (since C++ 11)
## Какие проблемы мы пытаемся решить
### Мотивация 1
Что тут происходит? (до C++11)
```cpp
std::vector<std::string> v;
v.push_back("Some fun text");
```
1. Конструирование временной строки из строкового литерала: выделение памяти в куче, копирование данных из литерала
2. Расширение вектора: выделение памяти в куче под новый элемент
3. Размещение только что созданой строки в вектор, то есть копирование строки (а значит ещё одно выделение памяти в куче и ещё одно копирование самого текста)

А нам точно нужен 3-й пункт? Зачем сперва создавать строку, выделять память, копировать текст, а потом заново делать то же самое. Не проще ли забрать всё от временной строки?
Проблема: у нас нет инструмента, который бы позволил забирать данные от объектов, которым они больше не нужны
## Мотивация 2
```cpp
struct JsonNode
{
  void SetValue(const std::string& value)
  {
    m_value = value;
  }

private:
  std::string m_value;
};

int main()
{
  JsonNode node;
  node.SetValue("Some fun text");
}
```
Проблема та же самая. Создаётся временный объект из строкового литерала. Сперва выделяется память под текст, потом копируется текст. А после этого происходит копирование временного объекта в поле класса, опять аллокации и копирование. Снова хочется просто забрать (**переместить**) все данные у временного, ведь они ему не нужны

**Решение пришло в С++11!**
## Как научить свой класс забирать данные у временных объектов
Напишем аналог std::string. Для того, чтобы наш класс умел забирать данные у временных объектов, нужно определить конструктор перещения и оператор перемещающего присваивания. Они отличаются от копирующих братьев тем, что принимают не const T&, а некую ссылку T&&. Видя эти конструкторы и операторы, компилятор будет вызывать именно их, если конструктор или оператор присваивания вызываются от временного объекта.
```cpp
struct String
{
    String() = default;
    String(const char* c)
    {
        // some actions
    }
    String(const String& other) // конструктор КОПИРОВАНИЯ
    {
      // some actions
    }
    String& operator=(const String& other) // оператор КОПИРУЮЩЕГО присваивания
    {
        // some actions
    }
    String(String&& other) // конструктор ПЕРЕМЕЩЕНИЯ
        : m_data(other.m_data), m_sz(other.m_sz) // Забираем данные у другого объекта
    {
        // обнуляем указатель и размер у другого объекта, чтобы он не вызвал delete[] в своём деструкторе и не инвалидировал наши данные
        other.m_data = nullptr;
        other.m_sz = 0;
    }
    String& operator=(String&& other) // оператор ПЕРЕМЕЩАЮЩЕГО присваивания
    {
        // Действия аналогично конструктору перемещение, только не освободить свои данные
        delete[] m_data;

        m_data = other.m_data;
        m_sz = other.m_sz;

        other.m_data = nullptr;
        other.m_sz = 0;
    
        return *this;
    }

    ~String()
    {
        delete[] m_data;
        m_sz = 0;
    }

private:
    char* m_data = nullptr;
    size_t m_sz = 0;
};
```
Конструктор перемещения и оператор перемещающего присваивания будут вызываться в тех случаях, когда их аргументом является выражение r-value
## А что такое это ваше r-value?
Если вкратце, то r-value это категория выражений, которую имею временные объекты. Постоянные объекты (те, что имеют адрес в памяти), называются l-value
> Для ассоциации запомнить можно так: int a = foo(). int a стоит слева, это lvalue. foo() стоит справа, это rvalue. Но это лишь пример для легкого запоминания! На самом деле суть r-value и l-value намного глубже и данный пример не отражает полной картины

## Формальное определение l-value и r-value
R-value и L-value это ни в коем случае не тип. Это категория выражения. Так какие выражения являются l или r-value
l-value                                   | r-value
------------------------------------------|----------------------------------------------------------------------
Переменные с id                           | Литералы (5, 'a', 1.0)
=, +=, -=, *=, /=, %=, <<=, &=, \|=, ^=   | +, -, *, /, %, <<, >>, &, \|, ^, &&, \|\|, !, ~, <, >, <=, >=, ==, !=
++expr, --expr                            | expr++, expr--
*ptr, array[i]                            | &id
Вызов функций, еcли функция возвращает T& | Вызов функций, еcли функция возвращает T или T&&
Теперь мы знаем, в каких случаях будет вызван конструктор перемещение (и оператор присваивания)
### Решение примера 2
Теперь попытаемся решить проблемы из примера 2. Для этого нам нужно сделать перегрузку конструктора для класса JsonNode, который мог бы принимать rvalue.

Вместо std::string будем использовать наш String, чтобы при желании можно было сделать логирование каждого конструктора и проверить всё вживую
```cpp
struct JsonNode
{
  SetValue(String& value)
  {
    m_value = value;
  }

  SetValue(String&& value) // перегрузка для r-value
  {
    m_value = value; // !!!
  }

private:
  String m_value;
};

int main()
{
  JsonNode node;
  node.SetValue("Some fun text");
}
```
Стало лучше? Нет. Осталась ещё одна проблема. В строчке с "!!!" всё равно вызывается конструктор копирования. Почему? Смотри табличку с определением l/r-value. Аргумент value имеет id, а следовательно это l-value. Таким образом мы **не** попадаем в оператор перемещающего приваивания
